#!/usr/bin/env bash

# Author: Wayne E. Seguin

usage() {
  echo -e "$(cat <<EOT

USAGE

  ${0//*/} <cmd> <args>

WHERE <cmd> IN

  init pg     - Initializes pg database servers from vault data, updates env vault
  init env    - Generates a kit env file from template via vault data
  init config - Generates bosh config files for an env from templates via vault data

  init <asgs|bastion|domains|isosegs|tcp> - Initializes specific features
  test <c2c|blacksmith|nfs|smb>           - Tests specific features

WHERE init-{pg,env,config} <args> IN

  region <region> # Required (except test|init)
  kit <kit-name>  # Required, bosh, vault, jumpbox, cf, blacksmith, shield,
                              autoscaler, scheduler, concourse
  env <env-name> # Required, Ex: ocfp-demo-mgmt-us-east-1, ocfp-demo-us-east-1
  vault-prefix "secret/...." # Optional, overrides default 'secret/'

NOTES

  Templates are expected at the path:
    -> ${0#ocfp}.

  Default templates can be enhanced/replaced for environment specific context.

EOT
)"
exit 0
}

fail() { echo -e "$*" >&2 ; exit 1 ; }

debug() { [[ -z ${DEBUG:-} ]] || echo -e "\e[93mDEBUG\e[0m: $*" >&2 ; }

parse::args() {
  debug "${FUNCNAME[0]}: $*"
  local _action

  while [[ $# > 0 ]]
  do
    _action="${1}" ; shift
    case ${_action} in
      (dep)
        deps+=( "${1//.yml}" )
        shift || fail "${0//*/} ... dep <env-name> # no .yml"
        ;;
      (vault-prefix)
        export OCFP_VAULT_PREFIX="${1}" # override default of secret/
        shift || fail "${0//*/} ... vault-prefix \"secret/...\""
        ;;
      (region)
        export OCFP_REGION=$1 # ex: us-east-1, us-west-2
        shift || fail "${0//*/} ... region <region>"
        ;;
      (kit)
        export OCFP_KIT=$1
        shift || fail "${0//*/} ... kit <name>"
        case ${OCFP_KIT} in
          (bosh|cf|blacksmith|shield|concourse|autoscaler|scheduler|vault|jumpbox|stratos) true ;;
          (*) fail "Unsupported kit: ${OCFP_KIT}" ;;
        esac ;;
      (env|name)
        export OCFP_ENV_NAME=${1//.yml}
        shift || fail "${0//*/} ... name <env-name> # ex: ocfp-codex-mgmt-us-east-1 / ocfp-codex-us-east-1"
        ;;
      (iaas)
        export OCFP_IAAS="$1"
        shift || fail "${0//*/} ... iaas <aws|azure|gcp|openstack|vsphere|warden>"
        case ${OCFP_IAAS} in
          #NOTE: Upstream are alicloud aws azure cloudstack docker gcp openstack softlayer vcloud virtualbox vsphere warden
          (aws|azure|gcp|openstack|vsphere|warden) true ;;
          (*) fail "Unsupported IAAS type: ${OCFP_IAAS}" ;;
        esac
        ;;
      (bosh)
        export OCFP_BOSH_ENV="$1"
        shift || fail "${0//*/} ... bosh <bosh-env-name>"
        ;;
      (type) 
        config_type="${1}"
        shift || fail "${0//*/} ... config <type>"
        ;;
      (scale) 
        config_scale="${1}"
        shift || fail "${0//*/} ... scale <type>"
        ;;
      (asgs|bastion|domains|isosegs|tcp) # Short circuit for init
        return 0
        ;;
      (c2c|blacksmith) # Short circuit for tests.
        return 0
        ;;
      (*)
        usage
        ;;
    esac
  done

  [[ -n ${OCFP_ENV_NAME} ]] || fail "'env <name>' must be given"
  if [[ ${cmd} != "test" ]]; then
    [[ -n ${OCFP_REGION} ]]   || fail "'region <region>' must be given"
    [[ -n ${OCFP_KIT} ]]      || fail "'kit <name>' must be given"
  fi

  set::env::type

  # All envs need to know their deployer/bosh_env, mgmt bosh is the exception
  if ! [[ ${OCFP_KIT} == "bosh" && ${env_type} == "mgmt" ]] && [[ $cmd != "test" ]]
  then [[ -n ${OCFP_BOSH_ENV} ]] || fail "'bosh <bosh-env-name>' must be given"
  fi

  case ${OCFP_KIT} in
    (bosh)
      [[ -n ${OCFP_IAAS} ]] || fail "'iaas <aws|gcp|azure>' must be given"
      ;;
  esac
}

set::vault::paths() {
  debug "${FUNCNAME[0]}: $*"
  local _env_path="${OCFP_ENV_NAME//-/\/}"
  export OCFP_VAULT_ENV_PATH="${OCFP_VAULT_PREFIX:-"/secret"}/${_env_path}"
  export OCFP_VAULT_TF_PATH="${OCFP_VAULT_PREFIX:-"/secret"}/tf/${_env_path}"
}

set::env::type() {
  debug "${FUNCNAME[0]}: $*"
  case "${OCFP_ENV_NAME}" in
    (*-mgmt-*) env_type="mgmt" ;;
    (*)        env_type="ocf"  ;;
  esac
  export OCFP_ENV_TYPE="${env_type}"
}

init::pg() {
  debug "${FUNCNAME[0]}: $*"
  echo -e "Initializing PG databases for env...\n\t-> ${OCFP_ENV_NAME}.yml"
  bash "${scripts_path}/templates/pg/init" env "${OCFP_ENV_NAME}" kit "${OCFP_KIT}" region "${OCFP_REGION}"
}

init::env() {
  debug "${FUNCNAME[0]}: $*"
  local _src_path _dst_path
  if [[ -s ${OCFP_ENV_NAME}.yml ]] 
  then fail "ERROR: ${OCFP_ENV_NAME}.yml already exists, rename it and re-run."
  fi

  _src_path="${OCFP_VAULT_TF_PATH}/bosh/iam/${env_type}"
  _dst_path="${OCFP_VAULT_ENV_PATH}/bosh"

  case "${OCFP_KIT}" in
    (bosh)
      case "${OCFP_IAAS}" in
        (aws)
          safe cp "${_src_path}/bosh" "${_dst_path}/aws"
          safe cp "${_src_path}/s3" "${_dst_path}/blobstore/s3"
          ;;
        (*) fail "Not Yet Implemented" ;;
      esac
      ;;
  esac

  if [[ -n ${OCFP_BOSH_ENV} ]]
  then safe set "${_dst_path}/env" bosh="${OCFP_BOSH_ENV}"
  fi

  echo -e "Generating Genesis Env File From Kit Template...\n\t-> ${OCFP_ENV_NAME}.yml"
  bash "${scripts_path}/templates/env/${OCFP_KIT}" > ${OCFP_ENV_NAME}.yml
  exit $?
}

init::config::cloud() {
  debug "${FUNCNAME[0]}: $*"
  local _config_path="${scripts_path}/templates/configs/${config_type}/${OCFP_IAAS}"
  local _meta="${scripts_path}/templates/configs/${config_type}/meta.yml"
  local _meta_prune="${scripts_path}/templates/configs/meta-prune.yml"
  local _target="configs/${config_type}/${OCFP_ENV_NAME}.yml"

  echo -e "Generating ${config_type} Config File for ${env_type} env with scale ${config_scale:-"dev"}...\n\t-> ${_target}"

  export OCFP_ENV_SCALE=${config_scale:-"dev"}

  declare -a _merge

  _merge=(
    "${_meta}"
    "${scripts_path}/templates/configs/cloud/meta/${env_type}.yml"
    "${_config_path}/scale/${env_type}.yml"
    "${_config_path}/${env_type}.yml"
  )

  _tmp_path=$(mktemp -d 2>/dev/null || mktemp -d -t 'ocfp')

  for dep in "${deps[@]}" ; do
    _dep_env="${dep%%@*}" # vault mount override via @<vault-mount>
    ( # Subshell so as to not clobber parents env vars
      case ${dep} in
        (*\@*) _vault_prefix="${dep##*\@}" ;;
        (*)    _vault_prefix="${OCFP_VAULT_PREFIX}" ;;
      esac

      # Override vault paths for dependent env
      OCFP_VAULT_ENV_PATH="${_vault_prefix}/${_dep_env//-/\/}"
      OCFP_VAULT_TF_PATH="${_vault_prefix}/tf/${_dep_env//-/\/}"
      OCFP_ENV_NAME="${_dep_env}"
      OCFP_ENV_TYPE="ocf"
      VAULT_PREFIX="${_vault_prefix}"

      _m=(
      "${_meta}"
      "${scripts_path}/templates/configs/cloud/meta/ocf.yml"
      "${_config_path}/azs/ocf.yml"
      "${_config_path}/networks/ocf-bosh.yml"
      "${_meta_prune}"
      )
      spruce merge -m "${_m[@]}" > "${_tmp_path}/${_dep_env}.yml"
    )
    _merge+=( "${_tmp_path}/${_dep_env}.yml" ) 
  done

  _merge+=( "${_meta_prune}")

  spruce merge -m "${_merge[@]}" > "${_target}"
}

init::config::cpi() {
  debug "${FUNCNAME[0]}: $*"
  local _src_path _dst_path

  _src_path="${OCFP_VAULT_PREFIX}/iam/${env_type}"
  _dst_path="${OCFP_VAULT_ENV_PATH}/bosh"

  local _target="configs/${config_type}/${OCFP_ENV_NAME}.yml"
  local _config_path="${scripts_path}/templates/configs/${config_type}"
  local _template="${_config_path}/${env_type}.yml"
  local _meta="${scripts_path}/templates/configs/${config_type}/meta.yml"
  local _meta_prune="${scripts_path}/templates/configs/meta-prune.yml"

  echo -e "Generating ${config_type} Config File for ${env_type} env with scale ${config_scale:-"dev"}...\n\t-> ${_target}"

  export OCFP_ENV_SCALE=${config_scale:-"dev"}

  declare -a _merge

  _merge=( "${_meta}" "${_template}" )

  local _tmp_path=$(mktemp -d 2>/dev/null || mktemp -d -t 'ocfp')

  for dep in "${deps[@]}" ; do
    _dep_env="${dep%%@*}" # vault mount override via @<vault-mount>
    ( # Subshell so as to not clobber parents env vars
      case ${dep} in
        (*\@*) _vault_prefix="${dep##*\@}" ;;
        (*)    _vault_prefix="${OCFP_VAULT_PREFIX}" ;;
      esac
      # Override vault paths for dependent env
      OCFP_VAULT_ENV_PATH="${_vault_prefix}/${_dep_env//-/\/}"
      OCFP_VAULT_TF_PATH="${_vault_prefix}/tf/${_dep_env//-/\/}"
      OCFP_ENV_NAME="${_dep_env}"
      VAULT_PREFIX="${_vault_prefix}"
      local _m=(
        "${_meta}"
        "${_config_path}/ocf.yml"
        "${_meta_prune}"
      )
      spruce merge -m "${_m[@]}" > "${_tmp_path}/${_dep_env}.yml"
    )
    _merge+=( "${_tmp_path}/${_dep_env}.yml" ) 
  done

  _merge+=( "${_meta_prune}")

  spruce merge -m "${_merge[@]}" > "${_target}"
}

init::config() {
  debug "${FUNCNAME[0]}: $*"
  case "${OCFP_KIT}" in
    (bosh)
      case "${OCFP_IAAS}" in
        (aws)
          #safe cp "${_src_path}/bosh" "${_dst_path}/aws"
          #safe cp "${_src_path}/s3" "${_dst_path}/blobstore/s3"
          ;;
        (*) fail "Not Yet Implemented" ;;
      esac
      ;;
  esac

  mkdir -p "configs/${config_type}"

  case ${config_type} in 
    (cloud)
      init::config::cloud "$@"
      ;;
    (cpi)
      init::config::cpi "$@"
      ;;
    (*) fail "Unsupported config type: ${config_type}, valid types are cloud,cpi" ;;
  esac

  exit $?
}

_test() {
  debug "${FUNCNAME[0]}: $*"
  case "$1" in 
    (c2c)
      bash "${scripts_path}/test/c2c" "${@:2}"
      ;;
    (blacksmith)
      bash "${scripts_path}/test/blacksmith" "${@:2}"
      ;;
    (nfs)
      bash "${scripts_path}/test/nfs" "${@:2}"
      ;;
    (smb)
      bash "${scripts_path}/test/smb" "${@:2}"
      ;;
    (*)
      fail "Usage: ${0//*\/} test {c2c}"
      ;;
  esac
}

init() {
  debug "${FUNCNAME[0]}: $*"
  case "$1" in 
    (pg)
      init::pg "$@"
      ;;
    (env)
      init::env "$@"
      ;;
    (config)
      init::config "$@"
      ;;
    (asgs)
      bash "${scripts_path}/init/asgs" "${@:2}"
      ;;
    (bastion)
      bash "${scripts_path}/init/bastion" "${@:2}"
      ;;
    (domains)
      bash "${scripts_path}/init/domains" "${@:2}"
      ;;
    (isosegs)
      bash "${scripts_path}/init/isosegs" "${@:2}"
      ;;
    (tcp)
      bash "${scripts_path}/init/tcp" "${@:2}"
      ;;
    (*)
      fail "Usage: ${0//*\/} init asgs|bastion|domains|isosegs|tcp"
      ;;
  esac
}

export DEBUG

scripts_path="$(dirname "${0}")"

cmd=$1 ; shift || usage

declare -a deps

parse::args "$@"

set::env::type

set::vault::paths # Sets vault paths for the main script level

if [[ -n ${VAULT_NAMESPACE} ]] ; then export VAULT_NAMESPACE ; fi
if [[ -n ${VAULT_VERSION} ]]   ; then export VAULT_VERSION ; fi

case ${cmd} in
  (test) _test "$@" ;;
  (init) init  "$@" ;;
  (*)    usage      ;;
esac

