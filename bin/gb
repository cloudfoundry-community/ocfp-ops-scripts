#!/usr/bin/env bash

# Author: Wayne E. Seguin

usage() {
  cat <<USAGE

OCFP Genesis BOSH Operations Script

USAGE: ${0//*\/} <sub-command>

WHERE <sub-command> is one of:

  bosh(b) -> Run a bosh cli command against given bosh env

    Usage: ${0//*\/} bosh <bosh-env-regex> <bosh-cli-command>
    Usage: ${0//*\/} <bosh-env-regex> <deployment-name-regexp> [options] [<job-name> <job-index> <log-file-name>]

      Where [options] are:
  
            --dir=      Destination directory (default: .)
        -f, --follow    Follow logs via SSH
            --num=      Last number of lines
        -q, --quiet     Suppresses printing of headers when multiple files are being examined
            --job=      Limit to only specific jobs
            --only=     Filter logs (comma-separated)
            --agent     Include only agent logs
  
    Examples:

      Show deps for ocfp-mgmt-us-east-1 bosh director:
      $ ${0//*\/} b mgmt-us-e deps
  
      Upload a release to the ocfp-mgmt-us-east-1 bosh director:
      $ ${0//*\/} b mgmt-us-e upload-release \$PWD/my-bosh-release-0.0.1.tgz
  
  logs(l) -> Fetch logs from given bosh env + dep and extrct into ~/logs/<env>/<dep>/
  
    Usage: ${0//*\/} logs|l <bosh-env-regex> <bosh-deployment-name-regex>

    Examples:

      Fetch diego-cell logs for cf from ocfp-sbx-us-east-1 bosh director:
      $ ${0//*\/} l sbx-us-e -cf diego-cell 
  
      Fetch gorouter logs from router vms using director ocfp-sbx-us-east-1 cf deployment:
      $ ${0//*\/} l sbx-us-e -cf router --job gorouter 
  
  ssh(s) -> Run bosh ssh against env and deployment
  
    Usage: ${0//*\/} ssh|s <bosh-env-regex> <bosh-deployment-name-regex> 

    Examples:

      ssh onto the first router for cf deployment on ocfp-sbx-us-east-1 bosh director:
      $ ${0//*\/} l sbx-us-e -cf router/0

  deps(d) -> Run bosh ssh against env and deployment
  
    Usage: ${0//*\/} deps|d <bosh-env-regex>

    Examples:

      Show deployments for ocfp-sbx-us-east-1
      $ ${0//*\/} d sbx-us-e
  
  
Environment Variables:
  
  BOSH_DEPLOYMENTS_PATH - Path to the genesis bosh kit deployments directory
                            Defaults to ~/deployments/bosh
  LOGS_PATH             - Logs path to download and process bosh logs into
                            Defaults to ~/logs
  
Prerequisites:
  
  safe     - cli in the path, targeting a vault, and authenticated
  genesis  - cli in the path
  bosh     - cli in the path

USAGE
}

fail() { 
  echo -e "\e[31mERROR:\e[0m $*" >&2
  exit 1
}

bosh::vaildate::environment() {
  local _cmd

  if [[ -n "${BOSH_DEPLOYMENTS_PATH}" ]]
  then bosh_path="${BOSH_DEPLOYMENTS_PATH}"
  else bosh_path="${HOME}/deployments/bosh"
  fi
  
  [[ -d "${bosh_path}" ]] ||
    fail "${FUNCNAME}:  BOSH deployments path '${bosh_path}' does not exist"
  
  for _cmd in genesis bosh safe
  do
    command -v "${_cmd}" &>/dev/null ||
      fail "${FUNCNAME}: \`${_cmd}\` was not found in PATH."
  done
}

find::env::file() {
  local _env="${1%.yml}" _env_file

  shift ||
    fail "${FUNCNAME}: find::env requires an environment name."

  local _yamls=($(
    find ${bosh_path} -maxdepth 1 -iname "*${_env}*.yml" -print |
      sort -d | head -1
  ))

  [[ ${#_yamls[@]} > 0 ]] ||
    fail "${FUNCNAME}: No bosh env files found matching regex '${_env}'"

  [[ ${#_yamls[@]} < 2 ]] ||
    fail "${FUNCNAME}: Multiple bosh env files found matching regex '${_env}': ${_yamls[*]}"

  [[ -s "${_yamls[0]}" ]] || fail "The env file '${_env_file}' is empty!"

  _env_file="${_yamls[0]}"

  echo "${_env_file}"
}

find::env() {
  local _env="${1%.yml}" _env_file

  shift ||
    fail "${FUNCNAME}: find::env requires an environment name."

  _env_file=$(find::env::file "${_env}")

  echo ${_env_file%.yml}
}

bosh::logs::fetch() {
  local _env_regex="${1%.yml}" _dep_regex="$2"
  shift 2 ||
    fail "${FUNCNAME}: bosh::logs requires an env regex followed by a deployment regex."

  local _logs_path="${LOGS_PATH:-"${HOME}/logs"}"
  local _env=$(find::env "${_env_regex}")
  local _env_name="${_env//*\/}"

  local _dep=$( bosh::dep ${_env_name} )

  [[ -n "${_dep}" ]] ||
    fail "${FUNCNAME}: No bosh deps found matching regex '${_dep_regex}' in env '${_env}'"

  echo -e "Fetching logs from bosh ${_env_name} deployment ${_dep}\n"
  bosh::do ${_env_name} -d ${_dep} logs "${@}"
  
  local _f _fn _job _vmid _ts

  local _dep_logs_path="${_logs_path}/${_env_name}/${_dep}"
  mkdir -p "${_dep_logs_path}"

  local _archives=($(find "${bosh_path}" -maxdepth 1 -iname "${_dep}*.tgz" -print))
  for _f in "${_archives[@]}"
  do tar -zxf "${_f}" -C "${_dep_logs_path}" ; rm -f "${_f}"
  done

  echo
  local _dep_archives=($(find "${_dep_logs_path}" -maxdepth 1 -iname '*.tgz' -print))
  for _f in "${_dep_archives[@]}"
  do
    _fn=$(basename ${_f//*\/})
    _job=$(echo ${_fn}  | awk -F. '{print $1}')
    _vmid=$(echo ${_fn} | awk -F. '{print $2}')
    _ts=$(echo ${_fn}   | awk -F. '{print $3}')
  
    echo -e "Extracting logs into ${_dep_logs_path}/${_job}/"
    mkdir -p "${_dep_logs_path}/${_job}/${_vmid}/${_ts}"
    tar -zxf "${_f}" -C "${_dep_logs_path}/${_job}/${_vmid}/${_ts}" 
    rm -f "${_f}"
  done
}

bosh::ssh() {
  local _env_regex="${1%.yml}" _dep_regex="$2"

  shift 2 ||
    fail "${FUNCNAME}: bosh::ssh requires an env regex followed by a deployment regex."

  local _env=$(find::env "${_env_regex}")

  _dep=( $(bosh::dep ${_env}) )

  [[ -n "${_dep}" ]] ||
    fail "${FUNCNAME}: No bosh deps found matching regex '${_dep_regex}' in env '${_env}'"

  bosh::do ${_env_name} -d ${_dep} ssh "${@}"
}

bosh::do() {
  local _env="${1%.yml}" 

  shift ||
    fail "${FUNCNAME}: bosh::do requires an environment name."
  
  _env_file="$(find::env::file "${_env}")"
  (
    cd "${bosh_path}"
    eval "$(genesis ${_env_file} bosh -A --connect)"
    exec bosh "$@"
  )
}

bosh::deps() {
  local _env="${1}"

  shift ||
    fail "${FUNCNAME}: bosh::deps requires an environment name."

  bosh::do "${_env}" deps --json &>/dev/null | jq -r '.Tables[].Rows[].name'
}

bosh::dep() {
  local _env=${1} _d

  shift ||
    fail "${FUNCNAME}: bosh::dep requires an environment name."

  for _d in $( $(bosh::deps ${_env}) ) 
  do [[ "${_d}" =~ ${_dep_regex} ]] && echo ${_d} && break
  done
}

bosh::manifest() {
  local _env="${1}" _dep_regex="$2" _dep

  shift 2 ||
    fail "${FUNCNAME}: bosh::manifest requires an env regex followed by a deployment regex."

  _dep=$( bosh::dep ${_env} )

  bosh::do ${_env} -d ${_dep} manifest "${@}"
}

bosh::vms::do() {
  local _env_regex="$1" _dep_regex="$2"

  shift 2 ||
    fail "${FUNCNAME}: bosh::vms requires an env regex followed by a deployment regex."
  vms=($(
    bosh::do "${_env}" -d "${_dep}" vms --json |
    jq -r '.Tables[].Rows[].instance' | 
    tr -d '"'
  ))

  for _vm in "${vms[@]}"
  do bosh::do "${_env}" -d "${_dep}" ssh "${_vm}" "$@"
  done
}

cmd="${1}" ; shift

bosh::vaildate::environment
  
case "${cmd}" in
  (b|bosh)     
    bosh::do "${@}" 
    ;;
  (l|logs)     
    bosh::logs::fetch "${@}" 
    ;;
  (s|ssh)      
    bosh::ssh "${@}" 
    ;;
  (d|deps)     
    bosh::deps "${@}" 
    ;;
  (m|manifest) 
    bosh::manifest "${@}" 
    ;;
  (vmsdo)      
    bosh::vms::do "${@}" 
    ;;
  (--help|-h|usage|*)
    usage 
    exit 0
    ;;
esac

exit 0
