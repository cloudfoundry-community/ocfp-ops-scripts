#!/usr/bin/env bash

# Author: Wayne E. Seguin

usage() {
  cat <<USAGE

OCFP Genesis BOSH Operations Script

USAGE: ${0//*\/} <sub-command>

WHERE <sub-command> is one of:

  bosh(b) -> Run a bosh cli command against given bosh env

    Usage: ${0//*\/} bosh <bosh-env-regex> <bosh-cli-command>
    Usage: ${0//*\/} <bosh-env-regex> <deployment-name-regexp> [options] [<job-name> <job-index> <log-file-name>]

      Where [options] are:
  
            --dir=      Destination directory (default: .)
        -f, --follow    Follow logs via SSH
            --num=      Last number of lines
        -q, --quiet     Suppresses printing of headers when multiple files are being examined
            --job=      Limit to only specific jobs
            --only=     Filter logs (comma-separated)
            --agent     Include only agent logs
  
    Examples:

      Show deps for ocfp-mgmt-us-east-1 bosh director:
      $ ${0//*\/} b mgmt-us-e deps
  
      Upload a release to the ocfp-mgmt-us-east-1 bosh director:
      $ ${0//*\/} b mgmt-us-e upload-release \$PWD/my-bosh-release-0.0.1.tgz
  
  logs(l) -> Fetch logs from given bosh env + dep and extrct into ~/logs/<env>/<dep>/
  
    Usage: ${0//*\/} logs|l <bosh-env-regex> <bosh-deployment-name-regex>

    Examples:

      Fetch diego-cell logs for cf from ocfp-sbx-us-east-1 bosh director:
      $ ${0//*\/} l sbx-us-e -cf diego-cell 
  
      Fetch gorouter logs from router vms using director ocfp-sbx-us-east-1 cf deployment:
      $ ${0//*\/} l sbx-us-e -cf router --job gorouter 
  
  ssh(s) -> Run bosh ssh against env and deployment
  
    Usage: ${0//*\/} ssh|s <bosh-env-regex> <bosh-deployment-name-regex> 

    Examples:

      ssh onto the first router for cf deployment on ocfp-sbx-us-east-1 bosh director:
      $ ${0//*\/} l sbx-us-e -cf router/0

  deps(d) -> Run bosh ssh against env and deployment
  
    Usage: ${0//*\/} deps|d <bosh-env-regex>

    Examples:

      Show deployments for ocfp-sbx-us-east-1
      $ ${0//*\/} d sbx-us-e
  
  
Environment Variables:
  
  BOSH_DEPLOYMENTS_PATH - Path to the genesis bosh kit deployments directory
                            Defaults to ~/deployments/bosh
  LOGS_PATH             - Logs path to download and process bosh logs into
                            Defaults to ~/logs
  
Prerequisites:
  
  safe     - cli in the path, targeting a vault, and authenticated
  genesis  - cli in the path
  bosh     - cli in the path

USAGE
}

fail() { echo -e "$*" >&2; exit 1; }

bosh::vaildate::environment() {
  local _cmd

  if [[ -n "${BOSH_DEPLOYMENTS_PATH}" ]]
  then bosh_path="${BOSH_DEPLOYMENTS_PATH}"
  else bosh_path="${HOME}/deployments/bosh"
  fi
  
  [[ -d "${bosh_path}" ]] ||
    fail "BOSH deployments path '${bosh_path}' does not exist"
  
  for _cmd in genesis bosh safe ; do 
    command -v "${_cmd}" &>/dev/null ||
      fail "ERROR: \`${_cmd}\` is not in PATH, please install it and try again."
  done
}

find::env::file() {
  local _env_regex="${1%.yml}"
  local _env_file
  local _yamls=($(
  find ${bosh_path} -maxdepth 1 -iname "*${_env_regex}*.yml" -print | sort -r | head -1
  ))

  if [[ ${#_yamls[@]} -eq 0 ]]
  then fail "No bosh env files found matching regex '${_env_regex}'"
  elif [[ ${#_yamls[@]} -gt 1 ]]
  then fail "Multiple bosh env files found matching regex '${_env_regex}': ${_yamls[*]}"
  fi

  _env_file="${_yamls[0]}"
  [[ -s "${_env_file}" ]] || 
    fail "ERROR: No bosh environment found matching '${_env_regex}' or file is empty"

  echo "${_env_file}"
}

find::env() {
  local _env_regex="${1%.yml}"
  local _env_file
  _env_file=$(find::env::file "${_env_regex}")
  echo ${_env_file%.yml}
}

bosh::logs::fetch() {
  local _env_regex="${1%.yml}" _dep_regex="$2"
  shift 2 || fail "$(usage)"

  local _logs_path="${LOGS_PATH:-"${HOME}/logs"}"
  local _env=$(find::env "${_env_regex}")
  local _env_name="${_env//*\/}"

  local deps=($(bosh::deps ${_env_name}))
  local _d _dep
  for _d in ${deps[@]}
  do
    if [[ "${_d}" =~ ${_dep_regex} ]]
    then _dep="${_d}" ; break
    fi
  done

  [[ -n "${_dep}" ]] || fail "No bosh deps found matching regex '${_dep_regex}' in env '${_env}'"

  echo -e "Fetching logs from bosh ${_env_name} deployment ${_dep}\n"
  bosh::do ${_env_name} -d ${_dep} logs "${@}"
  
  local _f _fn _job _vmid _ts

  local _dep_logs_path="${_logs_path}/${_env_name}/${_dep}"
  mkdir -p "${_dep_logs_path}"

  local _archives=($(find "${bosh_path}" -maxdepth 1 -iname "${_dep}*.tgz" -print))
  for _f in "${_archives[@]}"
  do tar -zxf "${_f}" -C "${_dep_logs_path}" ; rm -f "${_f}"
  done

  echo
  local _dep_archives=($(find "${_dep_logs_path}" -maxdepth 1 -iname '*.tgz' -print))
  for _f in "${_dep_archives[@]}"
  do
    _fn=$(basename ${_f//*\/})
    _job=$(echo ${_fn}  | awk -F. '{print $1}')
    _vmid=$(echo ${_fn} | awk -F. '{print $2}')
    _ts=$(echo ${_fn}   | awk -F. '{print $3}')
  
    echo -e "Extracting logs into ${_dep_logs_path}/${_job}/"
    mkdir -p "${_dep_logs_path}/${_job}/${_vmid}/${_ts}"
    tar -zxf "${_f}" -C "${_dep_logs_path}/${_job}/${_vmid}/${_ts}" 
    rm -f "${_f}"
  done
}

bosh::ssh() {
  local _env_regex="${1%.yml}" _dep_regex="$2"
  shift 2 || fail "$(usage)"

  local _logs_path="${LOGS_PATH:-"${HOME}/logs"}"
  local _env=$(find::env "${_env_regex}")
  local _env_name="${_env//*\/}"

  local deps=($(bosh::deps ${_env_name}))
  local _d _dep
  for _d in ${deps[@]}
  do
    if [[ "${_d}" =~ ${_dep_regex} ]]
    then _dep="${_d}" ; break
    fi
  done

  bosh::do ${_env_name} -d ${_dep} ssh "${@}"
}

bosh::do() {
  local _env_regex="${1%.yml}" 
  shift || fail "$(usage)"
  
  _env_file="$(find::env::file "${_env_regex}")"
  (
    cd "${bosh_path}"
    eval "$(genesis ${_env_file} bosh -A --connect)"
    exec bosh "$@"
  )
}

bosh::deps() {
  local _env="$1"
  shift || fail "$(usage)"
  bosh::do "${_env}" deps --json &>/dev/null | jq -r '.Tables[].Rows[].name'
}

bosh::vms::do() {
  local _env_regex="$1" _dep_regex="$2"
  shift 2 || fail "$(usage)"

  vms=($(
    bosh::do "${_env}" -d "${_dep}" vms --json |
    jq -r '.Tables[].Rows[].instance' | 
    tr -d '"'
  ))

  for _vm in "${vms[@]}"
  do bosh::do "${_env}" -d "${_dep}" ssh "${_vm}" "$@"
  done
}

cmd="${1}" ; shift

bosh::vaildate::environment
  
case "${cmd}" in
  (b|bosh)     
    bosh::do "${@}" 
    ;;
  (l|logs)     
    bosh::logs::fetch "${@}" 
    ;;
  (s|ssh)      
    bosh::ssh "${@}" 
    ;;
  (d|deps)     
    bosh::deps "${@}" 
    ;;
  (m|manifest) 
    bosh::manifest "${@}" 
    ;;
  (vmsdo)      
    bosh::vms::do "${@}" 
    ;;
  (*)
    usage 
    exit 0
    ;;
esac

exit 0

