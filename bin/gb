#!/usr/bin/env bash

# Author: Wayne E. Seguin

usage() {
  cat <<USAGE

OCFP Genesis BOSH Script

  There are two sub command paths as described below.

(b|bosh|d|director) -> 

  Genesis BOSH Director do
  
  Usage: ${0//*\/} <bosh-env-regex> [bosh director cli args]
  
  Environment variables:
  
    BOSH_DEPLOYMENTS_PATH - Path to the genesis bosh kit deployments directory
                            Defaults to ~/deployments/bosh
  
  Required:
  
    bosh-env-regex - Regex to match the bosh environment to use
  
  Prerequisites:
  
    safe     - cli in the path, targeting a vault, and authenticated
    genesis  - cli in the path
    bosh     - cli in the path

(l|logs) -> 

  Genesis BOSH Logs Fetcher
  
  Usage: ${0//*\/} <bosh-env-regex> <deployment-name-regexp> [<job-name> <job-index> <log-file-name>]
  
  WHERE [options] are:
  
            --dir=      Destination directory (default: .)
        -f, --follow    Follow logs via SSH
            --num=      Last number of lines
        -q, --quiet     Suppresses printing of headers when multiple files are being examined
            --job=      Limit to only specific jobs
            --only=     Filter logs (comma-separated)
            --agent     Include only agent logs
  
  Environment variables:
  
    LOGS_PATH       - Logs path to download and process bosh logs into

(vmsdo) -> 
  
    Genesis BOSH VMs do

    Run commands on all VMs in a deployment
    
    Usage: ${0//*\/} <bosh-env-regex> <deployment-name-regexp> <cmd>
    
    Required:
    
      bosh-env-regex - Regex to match the bosh environment to use
      deployment-name-regexp - Regex to match the deployment name to use
      vm-name-regexp - Regex to match the vm name to use
    
Prerequisites:
    
      safe     - cli in the path, targeting a vault, and authenticated
      genesis  - cli in the path
      bosh     - cli in the path

USAGE
}

fail() { echo -e "$*" >&2; exit 1; }

bosh::vaildate::environment() {
  if [[ -n "${BOSH_DEPLOYMENTS_PATH}" ]]
  then bosh_path="${BOSH_DEPLOYMENTS_PATH}"
  else bosh_path="${HOME}/deployments/bosh"
  fi
  
  [[ -d "${bosh_path}" ]] ||
    fail "BOSH deployments path '${bosh_path}' does not exist"
  
  for cmd in genesis bosh safe ; do 
    command -v "${cmd}" &>/dev/null ||
      fail "ERROR: \`${cmd}\` is not in PATH, please install it and try again."
  done
}

find::env::file() {
  local _env_regex="${1}"
  local _env_file
  local _yamls=($(
  find ${bosh_path} -maxdepth 1 -iname "*${_env_regex}*.yml" -print | sort -r | head -1
  ))

  if [[ ${#_yamls[@]} -eq 0 ]]
  then fail "No bosh env files found matching regex '${_env_regex}'"
  elif [[ ${#_yamls[@]} -gt 1 ]]
  then fail "Multiple bosh env files found matching regex '${_env_regex}': ${_yamls[*]}"
  fi

  _env_file="${_yamls[0]}"
  [[ -s "${_env_file}" ]] || 
    fail "ERROR: No bosh environment found matching '${_env_regex}' or file is empty"

  echo "${_env_file}"
}

find::env() {
  local _env_regex="${1}"
  local _env_file
  _env_file=$(find::env::file "${_env_regex}")
  echo ${_env_file%.yml}
}

bosh::logs::fetch() {
  local _env_regex="$1" _dep_regex="$2"
  shift 2 || fail "$(usage)"
  local _logs_path="${LOGS_PATH:-"${HOME}/logs"}"
  local _env=$(find::env "${_env_regex}")
  local _env_name="${_env//*\/}"

  local deps=($(bosh::deps ${_env_name}))
  local _d _dep
  for _d in ${deps[@]}
  do
    if [[ "${_d}" =~ ${_dep_regex} ]]
    then _dep="${_d}" ; break
    fi
  done

  [[ -n "${_dep}" ]] || fail "No bosh deps found matching regex '${_dep_regex}' in env '${_env}'"

  bosh::do ${_env_name} -d ${_dep} logs "${@}"
  
  local _f _fn _job _vmid _ts

  local _dep_logs_path="${_logs_path}/${_env_name}/${_dep}"
  mkdir -p "${_dep_logs_path}"

  local _archives=($(find "${bosh_path}" -maxdepth 1 -iname "${_dep}*.tgz" -print))
  for _f in "${_archives[@]}"
  do tar -zxf "${_f}" -C "${_dep_logs_path}" ; rm -f "${_f}"
  done

  local _dep_archives=($(find "${_dep_logs_path}" -maxdepth 1 -iname '*.tgz' -print))
  for _f in "${_dep_archives[@]}"
  do
    _fn=$(basename ${_f//*\/})
    _job=$(echo ${_fn}  | awk -F. '{print $1}')
    _vmid=$(echo ${_fn} | awk -F. '{print $2}')
    _ts=$(echo ${_fn}   | awk -F. '{print $3}')
  
    mkdir -p "${_dep_logs_path}/${_job}/${_vmid}/${_ts}"
  
    tar -zxf "${_job}.${_vmid}.${_ts}.tgz" \
      -C "${_dep_logs_path}/${_job}/${_vmid}/${_ts}"
  
    rm -f "${job}.${vmid}.${ts}.tgz"
  done
}

bosh::do() {
  local _env_regex="$1" 
  shift || fail "$(usage)"
  
  bosh::vaildate::environment
  
  _env_file="$(find::env::file "${_env_regex}")"
  (
    cd "${bosh_path}"
    eval "$(genesis ${_env_file} bosh -A --connect)"
    exec bosh "$@"
  )
}

bosh::deps() {
  local _env="$1"
  shift || fail "$(usage)"
  bosh::do "${_env}" deps --json | jq -r '.Tables[].Rows[].name'
}

bosh::vms::do() {
  local _env_regex="$1" _dep_regex="$2"
  shift 2 || fail "$(usage)"

  vms=($(
    bosh::do "${_env}" -d "${_dep}" vms --json |
    jq -r '.Tables[].Rows[].instance' | 
    tr -d '"'
  ))

  for _vm in "${vms[@]}"
  do bosh::do "${_env}" -d "${_dep}" ssh "${_vm}" "$@"
  done
}

cmd="${1}" ; shift
case "${cmd}" in
  (b|bosh|d|director) bosh::do "${@}" ;;
  (l|logs) bosh::logs::fetch "$@" ;;
  (vmsdo) bosh::vms::do "${@}" ;;
  (-h|--help|*) usage ; exit 0 ;;
esac

exit 0

