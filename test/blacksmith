#!/usr/bin/env bash
#
# ocfp test blacksmith env <name> services-create [redis|rabbitmq]
# wait....
# ocfp test blacksmith env <name> apps-push [redis|rabbitmq]
# ocfp test blacksmith env <name> apps-test [redis|rabbitmq]
# ocfp test blacksmith env <name> apps-delete [redis|rabbitmq]
# ocfp test blacksmith env <name> services-delete [redis|rabbitmq]
# party....
#

################################################################################
# Functions
################################################################################
 
fail() { echo -e "\e[31mERROR:\e[0m $*" >&2 ; exit 1 ; }

run() { echo -e "\$ $*" >&2; "$@"; }

debug() { [[ -z ${DEBUG:-} ]] || echo -e "\e[93mDEBUG\e[0m: $*" >&2 ; }

usage() {
  fail "Usage: ${0//*\/} <fetch|push|test|delete|setup|all> <space> [<space> ...]"
}

header() {
  local token="=" line=$(printf "${token}%.0s" {1..80})
  echo -e "\n${line}\n${token} $*\n${line}"
}

parse::args() {
  debug "${FUNCNAME} $*"
  while [[ $# > 0 ]]
  do
    case $1 in
      (services-create|services-delete|apps-push|apps-test|apps-delete)
        action=${1}
        shift
        ;;
      (e|env)
        env=$2
        shift 2 || fail "Usage: ...env <name>"
        ;;
      (rabbitmq|redis|postgres)
        services+=( ${1} ) ; shift 1
        ;;
      (*)
        fail "Unknown arg: '$1'\nUsage: env <name> space <name> [space <name>...] <cmd>"
        ;;
    esac
  done

  if [[ ${#services[@]} == 0 ]]
  then
    services=($( ls -1 ${apps_path} |
      grep -E 'cf-.*-example-app-master.zip' |
      sed -E 's/cf-(.*)-example-app-master.zip/\1/'
          ))
  fi
}

cf::login() {
  debug "${FUNCNAME} $*"
  local env=$1
  ( cd ~/deployments/cf
    genesis ${env} do login
  ) || fail "Failed to login to ${env}!"
}
 
apps::fetch() {
  debug "${FUNCNAME} $*"
  local service=$1
  local archive="cf-${service}-example-app-master.zip"
  if [[ ! -d ${apps_path}/${archive/.zip} ]]
  then
    if ! [[ -s ${apps_path}/${archive} ]]
    then
      ( cd ${apps_path}
        # curl -sOL ${RMQ_APP_URL}/${archive}
      )
    fi
    ( cd ${apps_path}
      run unzip /opt/ocfp/apps/${archive}
    )
  fi
}

app::push() {
  debug "${FUNCNAME} $*"
  local service=$1
  for index in a b
  do
    local archive="cf-${service}-example-app-master.zip"
    run cf push test-${service}-app-${index} --random-route \
      -p ${apps_path}/${archive/.zip} \
      -f ${apps_path}/${archive/.zip}/manifest.yml
  done
}

apps::push() {
  debug "${FUNCNAME} $*"
  for service in ${services[@]}
  do app::push ${service}
  done
}

apps::delete() {
  debug "${FUNCNAME} $*"
  for service in ${services[@]}
  do 
    for index in a b
    do run cf delete -f test-${service}-app-${index}
    done
  done
}

apps::app::uri() {
  debug "${FUNCNAME} $*"
  local app_name=$1
  local app_guid=$( cf app ${app_name} --guid )
  cf curl /v3/apps/${app_guid}/env |
    jq -r '.application_env_json.VCAP_APPLICATION.application_uris[0]'
}
 
apps::test() {
  debug "${FUNCNAME} $*"
  local service=$1 plan=$2
  local service_instance=test-${service}-${plan}
  test::${service} ${service_instance}
}
 
apps::test::plans() {
  debug "${FUNCNAME} $*"
  local service=$1
  local plans=($( service::plans ${service} ))
  for plan in ${plans[@]}
  do apps::test ${service} ${plan}
  done
}

apps::test::services() {
  debug "${FUNCNAME} $*"
  for service in ${services[@]}
  do apps::test::plans ${service}
  done
}

service::plans() {
  debug "${FUNCNAME} $*"
  local service=$1
  cf curl "/v3/service_plans?service_offering_names=${service}" | jq -r '.resources[].name'
}

service::instances() {
  debug "${FUNCNAME} $*"
  local service=$1 plan=$2
  local guid=$(service::plan::guid ${service} ${plan})
  cf curl "/v3/service_instances" | 
    jq -r '.resources[] | select(.relationships.service_plan.data.guid == "'${guid}'") | .name'
}

service::plan::guid() {
  debug "${FUNCNAME} $*"
  local service=$1 plan=$2
  cf curl "/v3/service_plans?service_offering_names=${service}" |
    jq -r '.resources[] | select(.name == "${plan}") | .guid'
}

service::plans::create() {
  debug "${FUNCNAME} $*"
  local service=$1 plan
  local -a plans=($( service::plans ${service} ))
  for plan in ${plans[@]}
  do
    run cf create-service ${service} ${plan} test-${service}-${plan}
  done
}

service::plans::delete() {
  debug "${FUNCNAME} $*"
  local service=$1 plan
  local -a plans=($( service::plans ${service} ))
  for plan in ${plans[@]}
  do
    run cf delete-service ${service} ${plan} test-${service}-${plan}
  done
}

service::plans::bind() {
  debug "${FUNCNAME} $*"
  local service=$1 plan
  local -a plans=($( service::plans ${service} ))
  for plan in ${plans[@]}
  do
    run cf bind-service test-${service}-app-a test-${service}-${plan}
    run cf restage test-${service}-app-a
  done
}

service::plans::unbind() {
  debug "${FUNCNAME} $*"
  local service=$1 plan
  local -a plans=($( service::plans ${service} ))
  for plan in ${plans[@]}
  do
    run cf unbind-service test-${service}-app-a test-${service}-${plan}
    # run cf restage test-${service}-app-a # ???
  done
}

services::create() {
  debug "${FUNCNAME} $*"
  local service
  for service in ${services[@]}
  do service::plans::create ${service}
  done
}

services::delete() {
  debug "${FUNCNAME} $*"
  local service
  for service in ${services[@]}
  do service::plans::delete ${service}
  done
}

services::bind() {
  debug "${FUNCNAME} $*"
  local service
  for service in ${services[@]}
  do service::plans::bind ${service}
  done
}

services::unbind() {
  debug "${FUNCNAME} $*"
  local service
  for service in ${services[@]}
  do service::plans::unbind ${service}
  done
}

autoscaler::policy() {
  cat > ${queue}-autoscaler-policy.json <<"EOF"
    {
      "instance_min_count": 1,
      "instance_max_count": 3,
      "scaling_rules": [
        {
          "metric_type": "${queue}_messages_ready",
          "threshold": 1,
          "operator": ">",
          "adjustment": "+1"
        },
        {
          "metric_type": "${queue}_messages_ready",
          "threshold": 2,
          "operator": "<",
          "adjustment": "-1"
        }
      ]
    }
EOF
}

test::rabbitmq() {
  debug "${FUNCNAME} $*"
  local \
    service_instance=$1 \
    app="https://$( apps::app::uri test-rabbitmq-app-a )" \
    queue=test_rabbit_queue
  
  run cf bind-service test-rabbitmq-app-a ${service_instance}
  run cf restage test-rabbitmq-app-a

  header "RabbiMQ - Testing Queues - Non TLS"

  echo -e "Pinging the rabbitmq app via the app url..."
  run curl -sk ${app}/ping

  echo -e "\nCreating queue ${queue}..."
  run curl -sk -X POST ${app}/queues -d "name=${queue}"

  echo -e "\nListing queues..."
  run curl -sk ${app}/queues

  echo -e "\nInserting a message into queue ${queue}..."
  run curl -sk -X PUT ${app}/queue/${queue} -d 'data=hello'

  echo -e "\nGetting messages from queue ${queue}..."
  run curl -sk -X GET ${app}/queue/${queue}

  header "RabbitMQ - Testing Queues - Enabling TLS for the app"

  run cf set-env test-rabbitmq-app-a RABBITMQ_USE_SSL true
  run cf restage test-rabbitmq-app-a

  header "RabbitMQ - Testing Queues - TLS"

  echo -e "Pinging the rabbitmq app via the app url..."
  run curl -sk ${app}/ping

  echo -e "\nCreating queue ${queue}..."
  run curl -sk -X POST ${app}/queues -d "name=${queue}"

  echo -e "\nListing queues..."
  run curl -sk ${app}/queues

  echo -e "\nInserting a message into queue ${queue}..."
  run curl -sk -X PUT ${app}/queue/${queue} -d 'data=hello'

  echo -e "\nGetting messages from queue ${queue}..."
  run curl -sk -X GET ${app}/queue/${queue}

  header "RabbitMQ - Testing Queues - Dynamic Credentials"

  run cf bind-service test-rabbitmq-app-b ${service_instance}
  run cf restage test-rabbitmq-app-b

  app_a_guid=$(cf app test-rabbitmq-app-a --guid)
  app_a_username=$( cf curl /v3/apps/${app_a_guid}/env |
    jq -r '.system_env_json.VCAP_SERVICES.rabbitmq[0].credentials.username'
  )

  app_b_guid=$(cf app test-rabbitmq-app-b --guid)
  app_b_username=$( cf curl /v3/apps/${app_b_guid}/env |
    jq -r '.system_env_json.VCAP_SERVICES.rabbitmq[0].credentials.username'
  )

  if [[ ${app_a_username} == ${app_b_username} ]]
  then echo "FAIL: The username for the service instance is the same for both apps!"
  else echo "PASS: The username for the service instance is not the same for both apps!"
  fi

  run cf create-service-key ${service_instance} rabbitmq-user-a
  run cf create-service-key ${service_instance} rabbitmq-user-b

  app_a_username=$( cf curl /v3/apps/${app_a_guid}/env |
    jq -r '.system_env_json.VCAP_SERVICES.rabbitmq[0].credentials.username'
  )
  app_b_username=$( cf curl /v3/apps/${app_b_guid}/env |
    jq -r '.system_env_json.VCAP_SERVICES.rabbitmq[0].credentials.username'
  )

  sk_a_guid=$(cf service-key ${service_instance} rabbitmq-user-a --guid)
  sk_a_username=$(cf curl /v2/service_keys/${sk_a_guid} | jq -r '.entity.credentials.username')

  sk_b_guid=$(cf service-key ${service_instance} rabbitmq-user-b --guid)
  sk_b_username=$(cf curl /v2/service_keys/${sk_b_guid} | jq -r '.entity.credentials.username')

  if [[ ${sk_a_username} == ${sk_b_username} ]]
  then echo "FAIL: The username for the service key is the same for both apps!"
  else echo "PASS: The username for the service key is not the same for both apps!"
  fi

  header "RabbitMQ - Testing Queues - Autoscaling based on Queue Depth"

  autoscaler::policy
  
  run cf create-service autoscaler autoscaler-free-plan test-rabbitmq-autoscaler
  run cf bind-service test-rabbitmq-app-a test-rabbitmq-autoscaler \
    -c ${queue}-autoscaler-policy.json
  
  rm ${queue}-autoscaler-policy.json

  echo -e "Restaging in preparation of testing autoscaling-history..."
  run cf restage test-rabbitmq-app-a

  echo -e "Starting app state..."
  run cf app test-rabbitmq-app-a

  echo -e "Creating the queue..."
  run curl -sk -X POST ${app}/queues -d "name=${queue}"

  echo -e "Inserting 10 messages into the queue '${queue}'..."
  for i in {1..10}
  do run curl -sk -X PUT ${app}/queue/${queue} -d "data=ciao-$i"
  done
  
  echo -e "Monitoring autoscaling-history for 5 minutes..."
  for i in {1..10}
  do
    run cf autoscaling-history test-rabbitmq-app-a
    echo -e "Sleeping for 30 seconds..."
    sleep 30
  done

  # Cleanup before next test.
  run cf unbind-service test-rabbitmq-app-a ${service_instance}
  run cf unbind-service test-rabbitmq-app-b ${service_instance}
}

test::redis() {
  debug "${FUNCNAME} $*"
  local service_instance=$1 cmd app_url app_guid
  declare -a cmds

  header "Redis - Testing - TLS & Non-TLS"
  
  local app=test-redis-app-a
  
  run cf bind-service ${app} ${service_instance}
  run cf restage ${app}

  app_url="https://$( apps::app::uri ${app} )"
  app_guid=$( cf app ${app} --guid )

  echo -e "\nInserting a Key/Value pair into Redis, key 'foo'..."
  result=$(run curl -k -X PUT ${app_url}/foo -d "data=bar")
  if [[ ${result} =~ "success" ]]
  then echo -e "PASS: Key/Value pair inserted successfully!"
  else echo -e "FAIL: Key/Value pair not inserted successfully!"
  fi

  echo -e "\nRetrieving the value for the key 'foo' non TLS..."
  result=$(run curl -k ${app_url}/foo)
  if [[ ${result} =~ "bar" ]]
  then echo -e "PASS: Value fetched successfully!"
  else echo -e "FAIL: Value not fetched successfully!"
  fi

  echo -e "\nRetrieving the value for the key 'foo' via TLS..."
  result=$(run curl -k ${app_url}/tls/v1.2/foo)
  if [[ ${result} =~ "bar" ]]
  then echo -e "PASS: Value fetched successfully via TLS!"
  else echo -e "FAIL: Value not fetched successfully via TLS!"
  fi

  header "Redis - Testing Disabled Commands"

  # TODO: bypass the network limitations with direct SSH commands.
  echo -e "SKIP: Test disabled due to network connectivity limitations."

  # redis_ip=$(
  # cf curl /v3/apps/${app_guid}/env |
  #   jq -r '.system_env_json.VCAP_SERVICES.redis[0].credentials.host'
  # )

  # redis_password=$(
  # cf curl /v3/apps/${app_guid}/env |
  #   jq -r '.system_env_json.VCAP_SERVICES.redis[0].credentials.password'
  # )

  # cmds=( CONFIG SAVE BGSAVE DEBUG SHUTDOWN SLAVEOF SYNC ACL )
  # for cmd in ${cmds[@]}
  # do
  #   response=$(redis-cli -h ${redis_ip} -p 6379 ${cmd} -a ${redis_password})
  #   if [[ ${response} =~ *ERR* ]]
  #   then echo -e "\n- Redis ${cmd} command is disabled"
  #   else echo -e "\n- Redis ${cmd} command is enabled"
  #   fi
  # done

  # Cleanup before next test.
  run cf unbind-service ${app} ${service_instance}
}

cf::space::create() {
  debug "${FUNCNAME} $*"
  run cf create-space -o ${org} ${space}
  run cf target -o ${org} -s ${space}
}

################################################################################
# Variables & Init
################################################################################
declare -a services apps spaces

declare \
  apps_path=${OCFP_PROJECT_PATH:-${HOME}/apps} \
  org=system \
  space=test-blacksmith-services \
  action

mkdir -p ${apps_path} && cd ${apps_path}

################################################################################
# Main
################################################################################
parse::args "$@"

cf::login ${env}

cf::space::create

for service in ${services[@]}
do apps::fetch ${service}
done

case ${action} in
  (services-create)
    services::create
    ;;
  (services-delete)
    services::delete
    ;;
  (apps-push)
    apps::push
    ;;
  (apps-test)
    apps::test::services
    ;;
  (apps-delete)
    apps::delete
    ;;
  (*) usage ;;
esac
 
exit 0
